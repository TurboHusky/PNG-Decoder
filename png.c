#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

#include "crc.h"
#include "adler32.h"

#ifdef __MINGW32__
   #define OS_TARGET "windows"
#endif

#ifdef __linux__
   #define OS_TARGET "linux"
#endif

#define UNUSED_CODE_LENGTH 0x80
#define CODE_LENGTH_ALPHABET_SIZE 19
#define ALPHABET_SIZE 16
#define ALPHABET_LIMIT 0x8000

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
   #define PNG_HEADER 0x0A1A0A0D474E5089
   #define PNG_IHDR 0x52444849
   #define PNG_PLTE 0x45544C50
   #define PNG_IDAT 0x54414449
   #define PNG_IEND 0x444e4549
   #define PNG_cHRM 0x4D524863
   #define PNG_gAMA 0x414D4167
   #define PNG_iCCP 0x50434369
   #define PNG_sBIT 0x54494273
   #define PNG_sRGB 0x42475273
   #define PNG_bKGD 0x44474B62
   #define PNG_hIST 0x54534968
   #define PNG_tRNS 0x534E5274
   #define PNG_pHYs 0x73594870
   #define PNG_sPLT 0x544C5073
   #define PNG_tIME 0x454D4974
   #define PNG_iTXt 0x74585469
   #define PNG_tEXt 0x74584574
   #define PNG_zTXt 0x7458547A
#elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
   #define PNG_HEADER 0x89504E470D0A1A0A                      
   #define PNG_IHDR 0x49484452
   #define PNG_PLTE 0x504C5445
   #define PNG_IDAT 0x49444154
   #define PNG_IEND 0x49454E44
   #define PNG_cHRM 0x6348524D
   #define PNG_gAMA 0x67414D41
   #define PNG_iCCP 0x69434350
   #define PNG_sBIT 0x73424954
   #define PNG_sRGB 0x73524742
   #define PNG_bKGD 0x624B4744
   #define PNG_hIST 0x68495354
   #define PNG_tRNS 0x74524E53
   #define PNG_pHYs 0x70485973
   #define PNG_sPLT 0x73504C54
   #define PNG_tIME 0x74494D45
   #define PNG_iTXt 0x69545874
   #define PNG_tEXt 0x74455874
   #define PNG_zTXt 0x7A545874
#else
   # error, endianess not defined
#endif

static inline uint32_t order_png32_t(uint32_t value)
{
   #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
      return (value & 0x000000FF) << 24 | (value & 0x0000FF00) << 8 | (value & 0x00FF0000) >> 8 | (value & 0xFF000000) >> 24;
   #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
      return value;
   #else
      # error, endianess not defined
   #endif
}

union dbuf 
{
   uint8_t byte;
   uint8_t buffer[4];
   uint16_t split[2];
   uint32_t stream;
};

struct extra_bits
{
   uint16_t value;
   uint8_t extra;
};

typedef struct extra_bits alphabet_t;

static const alphabet_t length_alphabet[29] = {
   {3, 0}, {4, 0}, {5, 0}, {6, 0}, {7, 0}, {8, 0}, {9, 0}, {10, 0},
   {11, 1}, {13, 1}, {15, 1}, {17, 1}, {19, 2}, {23, 2}, {27, 2}, {31, 2},
   {35, 3}, {43, 3}, {51, 3}, {59, 3}, {67, 4}, {83, 4}, {99, 4}, {115, 4},
   {131, 5}, {163, 5}, {195, 5}, {227, 5}, {258, 0}
}; // Lookup for 257-285

static const alphabet_t distance_alphabet[30] = {
   {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 1}, {7, 1}, {9, 2}, {13, 2},
   {17, 3}, {25, 3}, {33, 4}, {49, 4}, {65, 5}, {97, 5}, {129, 6}, {193, 6},
   {257, 7}, {385, 7}, {513, 8}, {769, 8}, {1025, 9}, {1537, 9}, {2049, 10}, {3073, 10},
   {4097, 11}, {6145, 11}, {8193, 12}, {12289, 12}, {16385, 13}, {24577, 13}
};

static const uint8_t reverse_nibble_lookup[16] = { 0x0, 0x8, 0x4, 0xC, 0x2, 0xA, 0x6, 0xE, 0x1, 0x9, 0x5, 0xD, 0x3, 0xB, 0x7, 0xF };

uint8_t reverse_byte(uint8_t n)
{
   return (reverse_nibble_lookup[n & 0x0F] << 4) | reverse_nibble_lookup[n >> 4];
}

void printbin(uint32_t n)
{
   uint32_t mask = 0x80000000;
   for(int i=31; i>=0; i--)
   {
      if(i%8 == 7)
      {
         printf(" ");
      }
      printf("%1d", (n&mask)>>i);
      mask>>=1;
   }
   printf("\n");
}

void decompress(unsigned char *buf, int len, uint8_t *out)
{ 
   uint8_t BFINAL = *buf & 0x01;
   uint8_t BTYPE = (*buf & 0x06) >> 1;

   printf("\nDecompressing...\nBFINAL: %d BTYPE: %d\n", BFINAL, BTYPE);

   union dbuf input;

   input.buffer[3] = reverse_byte(*buf);
   input.buffer[2] = reverse_byte(*(buf+1));
   input.buffer[1] = reverse_byte(*(buf+2));
   input.buffer[0] = reverse_byte(*(buf+3));

   uint32_t shift = 3;
   input.stream <<= shift;

   int index = 0;
   int out_index = 0;
   while(input.buffer[3]>2 && index<len) // 7-bit 0 maps to end of block (code 256)
   {
      alphabet_t test_alphabet = {0,0};
      if(input.buffer[3] < 48) // 7-bit codes, 1-47 maps to 257 - 279
      {
         test_alphabet = length_alphabet[(input.buffer[3] >> 1) - 1]; // map to 0-22 for lookup
         input.stream <<= 7;
         shift += 7;
      }
      else if(input.buffer[3] < 192) // 8-bit literals, 48-191 maps to 0-143
      {
         *(out+out_index) = input.buffer[3]-48;
         out_index++;
         printf("%d ", input.buffer[3]-48);
         input.stream <<= 8;
         shift += 8;
      }
      else if(input.buffer[3] < 200) // 8-bit codes, 192-199 maps to 280-287
      {
         test_alphabet = length_alphabet[input.buffer[3]-169]; // map to 23-28 for lookup
         input.stream <<= 8;
         shift += 8;
      }
      else // 9-bit literals, 200-255, read extra bit and map to 144-255
      {
         input.stream <<= 1;
         *(out+out_index) = input.buffer[3];
         out_index++;
         printf("%d ", input.buffer[3]);
         input.stream <<= 8;
         shift += 9;
      }

      if(test_alphabet.value)
      {
         uint16_t extra = 0;
         for (int i = 0; i < test_alphabet.extra; i++)
         {
            extra |= (input.buffer[3] & 0x80) >> (7 - i); // Read extra bits as machine integer (MSB first).
            input.stream <<= 1;
            shift++;
         }
         int copy_size = test_alphabet.value + extra;
         printf("%d:", test_alphabet.value + extra);
         test_alphabet = distance_alphabet[input.buffer[3] >> 3];
         input.stream <<= 5;
         shift += 5;

         extra = 0;
         for (int i = 0; i < test_alphabet.extra; i++)
         {
            extra |= (input.split[1] & 0x8000) >> (15 - i); // Read extra bits as machine integer (MSB first).
            input.stream <<= 1;
            shift++;
         }
         int offset = test_alphabet.value + extra;
         printf("%d ", test_alphabet.value + extra);
         while (copy_size > 0)
         {
            *(out+out_index) = *(out+out_index-offset);
            out_index++;
            copy_size--;
         }
         
      }
      uint32_t loop = shift >> 3;
      if(loop && index<len-4)
      {
         shift = shift % 8;
         input.stream >>= shift;
         for(int i=(int)loop-1; i>=0; i--)
         {
            input.buffer[i] = reverse_byte(*(buf+index+4));
            index++;
         }
         input.stream <<= shift;
      }
   }
}

uint8_t filter_type_0(uint8_t f, uint8_t a, uint8_t b, uint8_t c) {
   (void)a;
   (void)b;
   (void)c;
   return f;
}

uint8_t filter_type_1(uint8_t f, uint8_t a, uint8_t b, uint8_t c)
{
   (void)b;
   (void)c;
   return f+a;
}

uint8_t filter_type_2(uint8_t f, uint8_t a, uint8_t b, uint8_t c)
{
   (void)a;
   (void)c;
   return f+b;
}

uint8_t filter_type_3(uint8_t f, uint8_t a, uint8_t b, uint8_t c)
{
   (void)c;
   return f+((a+b)>>1);
}

uint8_t filter_type_4(uint8_t f, uint8_t a, uint8_t b, uint8_t c)
{
   int16_t p = a+b-c;
   int16_t pa = abs(p-a);
   int16_t pb = abs(p-b);
   int16_t pc = abs(p-c);
   return (pa<=pb) && (pa<=pc) ? f+a : (pb<=pc) ? f+b : f+c;
}

typedef uint8_t (*filter_t) (uint8_t, uint8_t, uint8_t, uint8_t);

void png_filter(uint8_t *buf, uint32_t width, uint32_t height, uint32_t offset)
{
   filter_t filters[5];
   filters[0] = filter_type_0;
   filters[1] = filter_type_1;
   filters[2] = filter_type_2;
   filters[3] = filter_type_3;
   filters[4] = filter_type_4;

   // Filtering works on bytes. For bit depth < 8 look for byte before x.
   uint8_t a = 0;    // Pixel samples:    c  b
   uint8_t b = 0;    //                   a  x
   uint8_t c = 0;
   uint8_t x = 0;
   
   uint32_t index = 0;
   uint32_t col_index = 1;
   uint8_t filter_type = *buf;

   // Remember first row entry is filter type, for pixel data:
   // First column a & c = 0, first row b & c = 0
   while(col_index <= offset)
   {
      x = *(buf+col_index);
      *(buf+index) = x;
      index++;
      col_index++;
   }
   while(col_index <= width)
   {
      x = *(buf+col_index);
      a = *(buf+col_index-offset-1); // Ok
      *(buf+index) = filters[filter_type](x, a, 0, 0);
      index++;
      col_index++;
   }

   for(uint32_t row_index=1; row_index<height; row_index++)
   {
      a=0;
      c=0;
      col_index = 1;
      filter_type = *(buf+(row_index*(width+1)));
      while(col_index <= offset)
      {
         x = *(buf+(row_index*(width+1))+col_index);
         b = *(buf+(row_index-1)*(width)+col_index-1);
         *(buf+index) = filters[filter_type](x, 0, b, 0);
         index++;
         col_index++;
      }
      while(col_index <= width)
      {
         x = *(buf+(row_index*(width+1))+col_index);
         a = *(buf+row_index*(width)+col_index-offset-1); // Ok
         b = *(buf+(row_index-1)*(width)+col_index-1);
         c = *(buf+(row_index-1)*(width)+col_index-offset-1);
         *(buf+index) = filters[filter_type](x, a, b, c);
         index++;
         col_index++;
      }
   }
}

void print_img_bytes(uint8_t *buf, uint32_t width, uint32_t height)
{
   for(uint32_t j=0; j<height; j++)
   {
      for(uint32_t i=0; i<width; i++)
      {
         printf("%02X ", *(buf + j*width + i));
      }
      printf("\n");
   }
}

enum colour_type_t { Greyscale=0, Truecolour=2, Indexed_colour=3, GreyscaleAlpha=4, TruecolourAlpha=6 };

void deinterlace(uint8_t *buf, uint32_t width, uint32_t height, uint8_t colour_type, uint8_t bit_depth)
{
   uint32_t bytes_per_pixel;
   uint32_t bits_per_pixel = bit_depth;

   switch(colour_type)
   {
      case Greyscale:
      case Indexed_colour:
         break;
      case Truecolour:
         bits_per_pixel *= 3;
         break;
      case GreyscaleAlpha:
         bits_per_pixel *= 2;
         break;
      case TruecolourAlpha:
         bits_per_pixel *= 4;
         break;
      default:
         printf("Error, unrecognised colour type\n");
         break;
   }
   bytes_per_pixel = bits_per_pixel >> 3;
   bits_per_pixel = bits_per_pixel % 8;

   uint32_t filter_spacing = (bytes_per_pixel < 1) ? 1 : bytes_per_pixel;

   uint32_t w = (width+7)>>3;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   uint32_t h = (height+7)>>3;
   png_filter(buf, w, h, filter_spacing);
   printf("Pass 1 : %d x %d\n", h, w);
   print_img_bytes(buf, w, h);
   int interlace_index = h*(w+1);

   w = (width+3)>>3;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 2 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
   interlace_index += h*(w+1);

   w = (width+3)>>2;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   h = (height+3)>>3;
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 3 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
   interlace_index += h*(w+1);

   w = (width+1)>>2;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   h = (height+3)>>2;
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 4 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
   interlace_index += h*(w+1);

   w = (width+1)>>1;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   h = (height+1)>>2;
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 5 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
   interlace_index += h*(w+1);

   w = width>>1;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   h = (height+1)>>1;
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 6 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
   interlace_index += h*(w+1);

   w = width;
   w = bytes_per_pixel * w + (((bits_per_pixel * w) + 0x07) >> 3);
   h = height>>1;
   png_filter(buf+interlace_index, w, h, filter_spacing);
   printf("Pass 7 : %d x %d\tindex: %d\n", h, w, interlace_index);
   print_img_bytes(buf+interlace_index, w, h);
}

void build_huffman(uint16_t *codes, int len, uint16_t *output, uint16_t *limits)
{
   struct
   {
      uint32_t count;
      uint32_t min;
      uint32_t max;
   } code_builder[ALPHABET_SIZE] = { 0 };

   for(int i=0; i<len; i++)
   {
      code_builder[*(codes+i)].count++;
   }
   for(int i=2; i<ALPHABET_SIZE; i++) 
   { 
      code_builder[i].min = (code_builder[i-1].count + code_builder[i-1].min) << 1; // Minimum starting values for each code length code
      code_builder[i].max = code_builder[i].min;
      *(limits+i) = code_builder[i].min;
   }
   code_builder[0].count = 0;
   for(int i=0; i<len; i++)
   {
      *(output+i) = code_builder[*(codes+i)].count > 0 ? (*(limits+(*(codes+i))))++ : ALPHABET_LIMIT;
   }
   // printf("\nHuffman builder:\nBits:\tCount:\tMin:\tMax +1:\n");
   // for(int i=0; i<ALPHABET_SIZE; i++){ printf("%d\t%d\t%d\t%d\n", i, code_builder[i].count, code_builder[i].min, code_builder[i].max); }
}

void decompress_dynamic(uint8_t *buf, int len, uint8_t *output)
{
   struct huf_build
   {
      uint32_t count;
      uint32_t min;
      uint32_t max;
   };

   // Common block header
   uint8_t BFINAL = *buf & 0x01;
   uint8_t BTYPE = (*buf & 0x06) >> 1;
   // Dynamic block header
   uint16_t HLIT = ((*buf & 0xf8) >> 3) + 257;
   uint8_t HDIST = (*(buf+1) & 0x1f) + 1;
   uint8_t HCLEN =  (((*(buf+2) & 0x01) << 3) | ((*(buf+1) & 0xe0) >> 5)) + 4; 
   printf("\nDecompressing...\nBFINAL: %d BTYPE: %d ", BFINAL, BTYPE);
   printf("HLIT: %d HDIST: %d HCLEN: %d\n", HLIT, HDIST, HCLEN);

   uint8_t code_length[CODE_LENGTH_ALPHABET_SIZE] = { 0 };
   union dbuf input;

   int index = 2; // Skip header bytes
   input.buffer[0] = *(buf+2);
   input.buffer[1] = *(buf+3);
   input.buffer[2] = *(buf+4);
   input.buffer[3] = *(buf+5);

   uint32_t shift = 1;
   input.stream >>= shift; // Apply offset from bit consumed by header
   
   // Read 4 - 19 code lengths
   uint8_t code_order[CODE_LENGTH_ALPHABET_SIZE] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
   struct huf_build code_length_builder[8] = { 0 };
   for (int i=0; i<HCLEN; i++)
   {
      code_length[code_order[i]] = input.buffer[0] & 0x07;
      code_length_builder[code_length[code_order[i]]].count++;
      input.stream >>= 3;
      shift += 3;

      // Load new byte into buffer
      if(shift>7 && index<len)
      {
         shift-=8;
         input.stream <<= shift;
         input.buffer[3] = *(buf+index+4);
         input.stream >>= shift;
         index++;
      }
   }
   // Calculate starting values for Huffman codes
   for(int i=2; i<8; i++) 
   { 
      code_length_builder[i].min = (code_length_builder[i-1].count + code_length_builder[i-1].min) << 1; // Minimum starting values for each code length code
      code_length_builder[i].max = code_length_builder[i].min;
   }
   // Build Huffman tree
   code_length_builder[0].count = 0;
   for(int i=0; i<CODE_LENGTH_ALPHABET_SIZE; i++)
   {
      code_length[i] = code_length_builder[code_length[i]].count > 0 ? code_length_builder[code_length[i]].max++ : UNUSED_CODE_LENGTH;
   }

   // printf("\tCode length Huffman codes : ");
   // for(int i=0; i<CODE_LENGTH_ALPHABET_SIZE; i++) { printf("%d ", code_length[i]); }
   // printf("\n");

   // Read Literal/Length length codes
   int alphabet_code_count = 0;
   uint16_t alphabet_codes[HLIT+HDIST];
   while(alphabet_code_count<HLIT+HDIST)
   {
      uint8_t test = input.buffer[0]&0x01;
      input.stream >>= 1;
      shift++;
      for(int code_bit_count=1; code_bit_count<=7; code_bit_count++)
      {
         if(test<code_length_builder[code_bit_count].max)
         {
            // printf("\t%d bit code, %d -> ", code_bit_count+1, test);
            int index = 0;
            while(code_length[index] != test && index < CODE_LENGTH_ALPHABET_SIZE)
            {
               index++;
            }
            uint8_t extra_bits = 0;
            switch(index)
            {
               case 16:
                  extra_bits = input.buffer[0] & 0x03;
                  input.stream >>= 2;
                  shift+=2;
                  // printf("%d:%d ", alphabet_codes[alphabet_code_count-1], 3+extra_bits);
                  for(int k=0; k<3+extra_bits; k++)
                  {
                     alphabet_codes[alphabet_code_count] = alphabet_codes[alphabet_code_count-1];
                     alphabet_code_count++;
                  }
                  break;
               case 17:
                  extra_bits = input.buffer[0] & 0x07;
                  input.stream >>= 3;
                  shift+=3;
                  // printf("0:%d ", 3+extra_bits);
                  for(int k=0; k<3+extra_bits; k++)
                  {
                     alphabet_codes[alphabet_code_count] = 0;
                     alphabet_code_count++;
                  }
                  break;
               case 18:
                  extra_bits = input.buffer[0] & 0x7f;
                  input.stream >>= 7;
                  shift+=7;
                  // printf("0:%d ", 11+extra_bits);
                  for(int k=0; k<11+extra_bits; k++)
                  {
                     alphabet_codes[alphabet_code_count] = 0;
                     alphabet_code_count++;
                  }
                  break;
               case 19:
                  printf("ERROR: Unrecognised code.\n");
                  break;
               default:
                  // printf("%d ", index);
                  alphabet_codes[alphabet_code_count] = index;
                  alphabet_code_count++;
                  break;
            }
            break; // Found Huffman code, leave loop
         }
         test = (test << 1) | (input.buffer[0]&0x01);
         input.stream >>= 1;
         shift++;
      }
      // Load new byte(s) into buffer
      index += shift >> 3;
      shift = shift % 8;
      input.stream = *((uint32_t*)(buf+index));
      input.stream >>= shift;
   }

   uint16_t literal_length_limits[ALPHABET_SIZE] = {0};
   build_huffman(alphabet_codes, HLIT, alphabet_codes, literal_length_limits);
   // printf("\n\tLiteral/Length alphabet codes: ");
   // for(int i=0; i<HLIT; i++) {printf("%d ", alphabet_codes[i]);}

   uint16_t distance_limits[ALPHABET_SIZE] = {0};
   build_huffman(&alphabet_codes[HLIT], HDIST, &alphabet_codes[HLIT], distance_limits);
   // printf("\n\n\tDistance alphabet codes: ");
   // for(int i=0; i<HDIST; i++) {printf("%d ", alphabet_codes[HLIT+i]);}
   // printf("\n\nData: ");

   int out_index = 0;
   int literal_length_index = 0;
   while(literal_length_index != 256 && index<(len))
   {
      index += shift >> 3;
      shift = shift % 8;
      input.stream = *((uint32_t*)(buf+index));
      input.stream >>= shift;

      uint16_t literal_length_code = 0;
      for(int bits=1; bits<=ALPHABET_SIZE; bits++)
      {
         // Read bit from stream
         literal_length_code = (literal_length_code << 1) | (input.buffer[0]&0x01);
         input.stream >>= 1;
         shift++;
         if(literal_length_code<literal_length_limits[bits])
         {
            // Literal alphabet lookup
            literal_length_index = 0;
            while(alphabet_codes[literal_length_index] != literal_length_code && literal_length_index < HLIT)
            {
               literal_length_index++;
            }

            if(literal_length_index<256)
            {
               // Literal
               *(output + out_index) = literal_length_index;
               out_index++;
            }
            else if(literal_length_index == 256)
            {
               // End code
               printf("Exit code\n");
            }
            else if(literal_length_index <286)
            {
               // Length code
               alphabet_t tmp = length_alphabet[literal_length_index-257];
               uint16_t length = tmp.value + (input.buffer[0] & (0xff >> (8-tmp.extra)));
               input.stream >>= tmp.extra;
               shift += tmp.extra;

               index += shift >> 3;
               shift = shift % 8;
               input.stream = *((uint32_t*)(buf+index));
               input.stream >>= shift;

               // Read Distance code
               uint8_t distance_code = 0;
               for(int distance_bit_count=1; distance_bit_count<=ALPHABET_SIZE; distance_bit_count++)
               {
                  distance_code = (distance_code << 1) | (input.buffer[0]&0x01);
                  input.stream >>= 1;
                  shift++;
                  if(distance_code<distance_limits[distance_bit_count])
                  {
                     int dist_index = HLIT;
                     while(alphabet_codes[dist_index] != distance_code && dist_index < HLIT+HDIST)
                     {
                        dist_index++;
                     }
                     alphabet_t dist_tmp = distance_alphabet[dist_index - HLIT];
                     uint32_t distance = dist_tmp.value + (input.stream & (0x0000ffff >> (16-dist_tmp.extra)));
                     for(int i=0; i<length; i++)
                     {
                        *(output + out_index) = *(output + out_index - distance);
                        out_index++;
                     }
                     input.stream >>= dist_tmp.extra;
                     shift += dist_tmp.extra;
                     break;
                  }
               }
            }
            else 
            {
               // Error
               printf(" ERROR::Unrecognised alphabet code.");
            }
            break;
         }
      }
   }
   uint32_t zlib_checksum = order_png32_t(*(uint32_t*)(buf + len));
   uint32_t A32 = adler32(output, out_index); // 192 Adler based on Deflate data (byte after FLG byte to byte before ADLER32 byte)
   if(A32 != zlib_checksum)
   {
      printf("ERROR::Invalid zlib checksum.");
   }

   printf("Decompressed data:\n");
   for(int i=0; i<out_index; i++) { printf("%02X ", *(output + i)); }

   printf("\nAdler32:\tComputed: %08X\n\t\tFile:     %08X\n", A32, zlib_checksum);

   printf("\nHLIT+HDIST: %d Codes Read: %d Bytes Read: %d Shift: %d\n", HLIT+HDIST, alphabet_code_count, index, shift);
}

int load_png(const char *filepath)
{
   size_t loaded;
   uint64_t header;

   // FILE *png_ptr = fopen("E:\\Users\\Ben\\Pictures\\bitmap.png", "rb");
   FILE *png_ptr = fopen(filepath, "rb");
   if (png_ptr == NULL)
   {
      printf("Failed to load file\n");
      return -1;
   }
   loaded = fread(&header, sizeof(header), 1, png_ptr);
   if (loaded != 1)
   {
      printf("Failed to read file\n");
      return -1;
   }
   if(header != PNG_HEADER)
   {
      printf("File is not a PNG\n");
      return -1;
   }
   printf("Loaded: %llu\n", loaded);
   
   long int filesize;
   fseek(png_ptr, 0L, SEEK_END);
   filesize = ftell(png_ptr);

   if(filesize < 0)
   {
      printf("Error determining file size\n");
      return -1;
   }
   printf("File size: %ld\n", filesize);
   fseek(png_ptr, sizeof(header), SEEK_SET);
   
   // Note name and crc do not contribute to chunk length
   struct
   {
      uint32_t name;
      uint32_t width;
      uint32_t height;
      uint8_t bit_depth;
      uint8_t colour_type;
      uint8_t compression_method;
      uint8_t filter_method;
      uint8_t interlace_method;
      uint32_t crc;
   }__attribute__((packed)) png_header;

   uint32_t chunk_length;
   fread(&chunk_length, sizeof(chunk_length), 1, png_ptr);
   chunk_length = order_png32_t(chunk_length);
   if(chunk_length != sizeof(png_header) - sizeof(png_header.crc) - sizeof(png_header.name))
   {
      printf("Error, invalid header size\n");
      return -1;
   }

   fread(&png_header, sizeof(png_header), 1, png_ptr);
   if(png_header.name != PNG_IHDR)
   {
      printf("Error, header chunk missing\n");
      return -1;
   }
   uint32_t crc_check = compute_crc((uint8_t*)&png_header, 17);
   crc_check = order_png32_t(crc_check);
   if(crc_check != png_header.crc)
   {
      printf("CRC check failed - Header corrupt\n");
      return -1;
   }

   png_header.width = order_png32_t(png_header.width);
   png_header.height = order_png32_t(png_header.height);
   // printf("Chunk: %c%c%c%c, Length: %u\n", (char)(png_header.name>>24), (char)(png_header.name>>16), (char)(png_header.name>>8), (char)png_header.name, png_header.length);
   printf("Width:              %u\n", png_header.width);
   printf("Height:             %u\n", png_header.height);
   printf("Bit Depth:          %u\n", png_header.bit_depth);
   printf("Colour Type:        %u\n", png_header.colour_type);
   printf("Compression Method: %u\n", png_header.compression_method);
   printf("Filter Method:      %u\n", png_header.filter_method);
   printf("Interlace Method:   %u\n", png_header.interlace_method);

   if(png_header.width == 0)
   {
      printf("Zero width detected\n");
      return -1;
   }
   if(png_header.height == 0)
   {
      printf("Zero height detected\n");
      return -1;
   }
   if(png_header.compression_method != 0)
   {
      printf("Undefined compression method specified\n");
      return -1;
   }
   if(png_header.filter_method != 0)
   {
      printf("Undefined filter method specified\n");
      return -1;
   }
   if(png_header.interlace_method != 0 && png_header.interlace_method != 1)
   {
      printf("Undefined interlace method specified\n");
      return -1;
   }

   switch(png_header.colour_type)
   {
      case Greyscale:
         if(!(png_header.bit_depth == 8 || png_header.bit_depth == 16 || png_header.bit_depth == 4 || png_header.bit_depth == 2 || png_header.bit_depth == 1))
         {
            printf("Illegal bit depth for colour type 0\n");
            return -1;
         }
         break;
      case Indexed_colour:
         if(!(png_header.bit_depth == 8 || png_header.bit_depth == 4 || png_header.bit_depth == 2 || png_header.bit_depth == 1))
         {
            printf("Illegal bit depth for colour type 3\n");
            return -1;
         }
         break;
      case Truecolour:
      case TruecolourAlpha:
      case GreyscaleAlpha:
         if(!(png_header.bit_depth == 8 || png_header.bit_depth == 16))
         {
            printf("Illegal bit depth for colour type %d\n", png_header.colour_type);
            return -1;
         }
         break;
      default:
         printf("Illegal colour type\n");
         return -1;
   }

   // Allocate memory here...
   // (Width+1)*height
   // Width depends on colour type and bit depth

   enum critical_chunks { IHDR=0, PLTE, IDAT, IEND } chunk_state = IHDR;

   while(chunk_state != IEND && fread(&chunk_length, sizeof(chunk_length), 1, png_ptr) != 0 && feof(png_ptr) == 0)
   {
      uint32_t chunk_name;
      chunk_length = order_png32_t(chunk_length);
      uint8_t *chunk_buffer = malloc(sizeof(chunk_name) + chunk_length + sizeof(crc_check));
      
      fread(chunk_buffer, sizeof(chunk_name) + chunk_length + sizeof(crc_check), 1, png_ptr);
      // fseek(png_ptr, chunk_length+4, SEEK_CUR); // Skip data for now
      crc_check = compute_crc(chunk_buffer, chunk_length + sizeof(chunk_name));
      if(crc_check != order_png32_t(*(uint32_t*)(chunk_buffer + sizeof(chunk_name) + chunk_length)))
      {
         printf("CRC check failed - chunk corrupt\n");
      }
      else
      {
         uint8_t CMF, FLG, CINFO, CM, FLEVEL, FDICT;
         uint16_t FCHECK_RESULT;
         uint8_t BFINAL, BTYPE;

         switch(*(uint32_t*)chunk_buffer)
         {
            case PNG_PLTE:
               printf("PLTE - Not implemented\n");
               break;
            case PNG_IDAT:
               CMF = *(chunk_buffer + sizeof(chunk_name));
               FLG = *(chunk_buffer + sizeof(chunk_name) + 1);
               FCHECK_RESULT = ((CMF << 8) | FLG) % 31;
               if(FCHECK_RESULT)
               {
                  printf("zlib FCHECK failed\n");
                  return -1;
               }
               CM = CMF & 0x0f;
               if(CM != 8)
               {
                  printf("Invalid compression method specified in zlib header\n");
                  return -1;
               }
               CINFO = CMF >> 4;
               if(CINFO > 7)
               {
                  printf("Invalid window size specified in zlib header\n");
                  return -1;
               }
               FDICT = (FLG & 0x20) >> 5;
               if(FDICT)
               {
                  printf("Dictionary cannot be specified for PNG in zlib header\n");
                  return -1;
               }
               FLEVEL = FLG >> 6;

               printf("IDAT - %d bytes\n\tCINFO: %02X\n\tCM: %02X\n\tFLEVEL: %02X\n\tFDICT: %02X\n\tFCHECK: %02X (%d)\n", chunk_length, CINFO, CM, FLEVEL, FDICT, FLG & 0x1f, FCHECK_RESULT);
               
               int zlib_offset = sizeof(chunk_name) + sizeof(CMF) + sizeof(FLG);
               int zlib_data_length = chunk_length - sizeof(CMF) - sizeof(FLG) - 4; // 4 = sizof(ADLER32), not implemented yet
               
               BFINAL = *(chunk_buffer + zlib_offset) & 0x01;
               BTYPE = (*(chunk_buffer + zlib_offset) & 0x06) >> 1;

               printf("\t\tBFINAL: %01X\n\t\tBTYPE: %01X\n", BFINAL, BTYPE);

               switch(BTYPE)
               {
                  case 0:
                     break;
                  case 1:
                     break;
                  case 2:
                     break;
                  case 3:
                     printf("Invalid Deflate compression in block header\n");
                     return -1;
               }

               // DECOMPRESS
               uint8_t tmp[5000];
               decompress_dynamic(chunk_buffer + zlib_offset, zlib_data_length, tmp);
               if(png_header.interlace_method == 1)
               {
                  deinterlace( tmp, png_header.width, png_header.height, png_header.colour_type, png_header.bit_depth );
               }

               //ADLER32 CHECK
               break;
            case PNG_IEND:
               printf("IEND\n");
               break;
            case PNG_cHRM:
            case PNG_gAMA:
            case PNG_iCCP:
            case PNG_sBIT:
            case PNG_sRGB:
            case PNG_bKGD:
            case PNG_hIST:
            case PNG_tRNS:
            case PNG_pHYs:
            case PNG_sPLT:
            case PNG_tIME:
            case PNG_iTXt:
            case PNG_tEXt:
            case PNG_zTXt:
               printf("Chunk not implemented\n");
               break;
            default:
               printf("Unknown chunk\n");
               break;
            case PNG_IHDR:
               printf("Error, invalid header chunk\n");
               break;
         }
         // printf("Length: %u\n", chunk_length);
      }

      free(chunk_buffer);
   }
   
   fclose(png_ptr);
   return 0;
}

int main(int argc, char *argv[])
{
   (void)argv[argc-1];
   printf("OS: %s\n", OS_TARGET);

   load_png(argv[1]);


   // uint8_t compressed_data[49] = { 0x63, 0xfc, 0xcf, 0x80, 0x1d, 0xb0, 0x30, 0xfc, 0xff, 0xcf, 0xc0, 0xc0, 0xc0, 0xf0, 0xef, 0x1f, 0x54, 0x80, 0x91, 0x11, 0x4a, 0x33, 0xe0, 0xd0, 0xc2, 0xf2, 0x1f, 0x87, 0x0c, 0x23, 0x03, 0x0e, 0x09, 0x96, 0xff, 0xb8, 0x6c, 0x47, 0x03, 0x0b, 0x27, 0x77, 0xaf, 0x98, 0x39, 0x11, 0x9f, 0x0a, 0x00 };
   // unsigned char test_data[200]; // 8px*3rgb*+1 x 8 lines
   // decompress(compressed_data, sizeof(compressed_data), test_data);
   // printf("\nDecompressed: "); for(int i=0; i<200; i++) { printf("%02X ", test_data[i]); }
   // uint32_t a32_check = adler32(test_data, sizeof(test_data));
   // printf("\nAdler32:   %02X %02X %02X %02X\n", (a32_check>>24)&0xff, (a32_check>>16)&0xff, (a32_check>>8)&0xff, a32_check&0xff);
   // printf("Should be: 5E 2B 0E 96\n");
   
//    printf("\nDecompressed:\n");
//    png_filter(test_data, 24, 8, 3);
//    // print_img_bytes(test_data, 24, 8); 

// //   uint8_t interlaced_data[] = { 0x03, 0xFF, 0x00, 0x00, 0xB2, 0x21, 0x6A, 0x05, 0x02, 0x0F, 0x5B, 0xF7, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x3C, 0x00, 0x00, 0xE2, 0x75, 0xD4, 0xEF, 0xC6, 0x15, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x26, 0x19, 0x5F, 0x00, 0x00, 0x00, 0x02, 0x18, 0x0D, 0x38, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x53, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x35, 0x00, 0x00, 0x06, 0x00, 0x00, 0xEE, 0x12, 0x0A, 0x23, 0xEE, 0xF5, 0xB5, 0x00, 0x35, 0x24, 0x7C, 0x23, 0x18, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x19, 0x56, 0xF7, 0xF9, 0xEE, 0x09, 0x07, 0x12, 0x21, 0xE8, 0xDC, 0x59, 0x00, 0x07, 0x01, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1D, 0x14, 0x69, 0xE3, 0xEE, 0xDF, 0x19, 0x0E, 0x01, 0x55, 0x0A, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3A, 0x1D, 0x11, 0x0A, 0xE3, 0xEF, 0xF6, 0x00, 0x00, 0xFA, 0x00, 0x00, 0xFC, 0xA8, 0x8A, 0xD0, 0x01, 0x00, 0x00, 0x17, 0x00, 0x00, 0xE9, 0x00, 0x01, 0x28, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x06, 0xB8, 0xB7, 0xC6, 0xC4, 0x48, 0x00, 0x00, 0x00, 0x01, 0x28, 0x00, 0x9B, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x02, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x01, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0x42, 0x26, 0x18, 0x24, 0x0F, 0x0B, 0x22, 0xCB, 0xDC, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x02, 0x34, 0x62, 0xFE, 0xDA, 0xEB, 0x00, 0xF0, 0x13, 0x01, 0x1C, 0x02, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0xA4, 0x96, 0x9A, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xBE, 0xDA, 0xE7, 0xD4, 0xFD, 0xFC, 0xE4, 0x00, 0xFF, 0xD8, 0x00, 0x00, 0x00, 0x00, 0xFD, 0xA4, 0xBB, 0x11, 0x0E, 0xDE, 0x1D, 0x4B, 0x0A, 0x05, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0C, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x00, 0x01, 0x3A, 0x00, 0xAE, 0x00, 0x00, 0x00, 0x00, 0xB3, 0x92, 0x00, 0x00, 0x00, 0x01, 0x28, 0x30, 0x21, 0x70, 0x00, 0x01, 0x34, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x86, 0xCE, 0x00, 0x51, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x99, 0x00, 0x00, 0x00, 0x04, 0x62, 0x00, 0x01, 0x34, 0x00, 0x03, 0x56, 0x00, 0x93, 0x6F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6D, 0xAF, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x7F, 0x00, 0xFE, 0xFE, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2F, 0x1F, 0x65, 0xF8, 0xFA, 0xF1, 0x00, 0x00, 0x09, 0xF7, 0xF9, 0xE5, 0x00, 0x00, 0x00, 0x21, 0x18, 0x3F, 0x17, 0xD7, 0xB4, 0x08, 0x00, 0xFA, 0x4B, 0x00, 0xED, 0x01, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x17, 0x00, 0x02, 0x2B, 0x37, 0x24, 0x3A, 0xE6, 0xEC, 0xC8, 0xE3, 0xEF, 0xE4, 0x00, 0x00, 0x0C, 0x00, 0x04, 0x44, 0x49, 0xFC, 0xBA, 0x40, 0x00, 0xF0, 0x04, 0x00, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0xFE, 0xE9, 0xC9, 0xDC, 0x13, 0x2B, 0x1B, 0x23, 0x00, 0xEF, 0xE4, 0x00, 0x03, 0x33, 0x30, 0x1C, 0xF8, 0xB7, 0xDF, 0xE5, 0xF6, 0x00, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 0x93, 0x8B, 0x00, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x17, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x00, 0x00, 0x00, 0x1D, 0x12, 0x44, 0x46, 0x18, 0x58, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x13, 0x55, 0x00, 0x01, 0x28, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x17, 0x00, 0x01, 0x3A, 0x28, 0xA4, 0x00, 0x03, 0x00, 0x02, 0x51, 0x24, 0x17, 0x25, 0xED, 0xF7, 0x31, 0x00, 0xFF, 0xD2, 0x00, 0x00, 0x00, 0xF2, 0xF9, 0x22, 0x00, 0xFF, 0xC6, 0x00, 0x00, 0xE0, 0x00, 0x02, 0x51, 0x00, 0x00, 0xF4, 0x00, 0x01, 0x09, 0x00, 0x7E, 0xCF, 0x70, 0xED, 0x00, 0x00, 0x00, 0x01, 0x3F, 0x26, 0x1D, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x42, 0x00, 0x00, 0x00, 0x00, 0x03, 0x59, 0x00, 0x00, 0x0D, 0x00, 0x03, 0x55, 0x00, 0x7F, 0x00, 0x90, 0x90, 0x00, 0x9E, 0x9E, 0x00, 0x28, 0x00, 0x00, 0x00, 0x26, 0x1A, 0x6D, 0x12, 0x0A, 0x36, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x34, 0x00, 0xA6, 0x00, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x03, 0x53, 0x00, 0x01, 0x3F, 0x00, 0x01, 0x28, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x72, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x75, 0x00, 0x00, 0x00, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x02, 0x4A, 0x00, 0x4C, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB7, 0x00, 0x00, 0x9E, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x55, 0x0F, 0x08, 0xF3, 0x0A, 0x06, 0x0B, 0xE7, 0xF1, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0xFF, 0xEE, 0x00, 0x03, 0x40, 0x25, 0xFD, 0xAA, 0x0F, 0x00, 0x14, 0xF1, 0x00, 0x01, 0x09, 0x01, 0x10, 0x18, 0x00, 0xFE, 0x0E, 0x01, 0x23, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x18, 0x00, 0x01, 0x1D, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC6, 0x33, 0x23, 0x7D, 0x04, 0x03, 0xFF, 0xC9, 0xDB, 0xAC, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD8, 0x00, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDD, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x13, 0x05, 0x22, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE9, 0x00, 0xFF, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x34, 0xF8, 0xFA, 0xED, 0xF2, 0xF5, 0xDA, 0x00, 0xFF, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x3A, 0x00, 0x00, 0x00, 0x12, 0x0A, 0x11, 0x1E, 0x16, 0x59, 0x0F, 0x0B, 0x1B, 0xDE, 0xE7, 0xCA, 0xE3, 0xEE, 0xEC, 0xC0, 0x18, 0x4B, 0x30, 0x0C, 0xE9, 0x04, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x28, 0x23, 0x17, 0x3E, 0x0F, 0x09, 0x06, 0xDD, 0xE7, 0xBD, 0xF1, 0xF8, 0xF4, 0x00, 0x00, 0x0D, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xF5, 0xB5, 0xEE, 0xDF, 0x00, 0x00, 0x01, 0x28, 0x00, 0x01, 0x1A, 0x00, 0x00, 0xE7, 0xF2, 0xE7, 0x74, 0x24, 0x00, 0x00, 0x04, 0x00, 0x01, 0x3A, 0x00, 0x02, 0x25, 0x00, 0xFF, 0xEE, 0x4F, 0x35, 0x56, 0xE2, 0xEA, 0xC7, 0xCF, 0xE0, 0xC2, 0x00, 0x00, 0x08, 0x00, 0xFF, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x13, 0x54, 0x00, 0x01, 0x23, 0xDD, 0xEB, 0xE3, 0x00, 0xFE, 0xE0, 0x00, 0xFF, 0xD7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x02, 0x4D, 0x00, 0xFF, 0xDB, 0x00, 0x7D, 0xBE, 0x00, 0x2F, 0x00, 0x03, 0xF5, 0x00, 0x07, 0x5D, 0x00, 0x03, 0x00, 0x00, 0xE3, 0x00, 0x01, 0x22, 0x00, 0xFE, 0xC8, 0x04, 0x02, 0x12, 0xD2, 0xE4, 0xF4, 0x00, 0xFE, 0xBA, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 0xF2, 0xF7, 0xFF, 0xF2, 0xF6, 0xA8, 0x00, 0xFF, 0xD3, 0x00, 0x01, 0x0F, 0x00, 0x00, 0x01, 0x00, 0x01, 0x2F, 0x00, 0x01, 0x17, 0x00, 0x03, 0x40, 0x00, 0xFF, 0xEA, 0x00, 0x01, 0x0E, 0x00, 0x90, 0xEC, 0x00, 0x55, 0xDA, 0x00, 0xB1, 0xEC, 0x51, 0x12, 0x00, 0x86, 0x2F, 0x00, 0x11, 0xD6, 0x00, 0xFD, 0x09, 0x00, 0x01, 0x4B, 0x34, 0xA1, 0xC4, 0xD6, 0xB1, 0x21, 0x17, 0x22, 0xF5, 0xF7, 0xE3, 0x06, 0x05, 0x14, 0xD5, 0xE3, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x6F, 0x00, 0xFB, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x23, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDD, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x9E, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xB3, 0xB3, 0x00, 0xAF, 0xAF, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x38, 0x00, 0x00, 0x01, 0x00, 0x02, 0x3C, 0x00, 0x02, 0x24, 0x00, 0xFC, 0xA0, 0x00, 0x00, 0x17, 0x00, 0x01, 0x1D, 0x00, 0xFF, 0xCC, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x12, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x81, 0x00, 0x00, 0x01, 0x30, 0x00, 0x01, 0x12, 0x00, 0xFE, 0xBE, 0x72, 0xA6, 0x00, 0x0D, 0xD9, 0x00, 0x81, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x7C, 0x00, 0x61, 0x0F, 0x00, 0x00, 0x00, 0x02, 0x4E, 0x00, 0x00, 0x17, 0x00, 0x01, 0x30, 0x00, 0x03, 0x5A, 0x00, 0x04, 0x64, 0x00, 0x01, 0x28, 0x00, 0x9B, 0x3A, 0x00, 0x51, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x03, 0x5A, 0x98, 0x98, 0x51, 0x57, 0xBA, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 0x00, 0x81, 0xB0, 0x00 };
// //   deinterlace(interlaced_data, sizeof(interlaced_data), 27, 19);
//    uint8_t interlaced_data[] = { 0x00, 0xBA, 0xFE, 0xCA, 0x22, 0x22, 0x22, 0x03, 0xE7, 0xC5, 0xDF, 0xEF, 0xEF, 0xEF, 0x00, 0x22, 0x22, 0x22, 0xBA, 0xFE, 0xCA, 0x01, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0xAA, 0xAA, 0xEE, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x88, 0x66, 0xEE, 0x03, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x01, 0xAA, 0xAA, 0xEE, 0x22, 0xBC, 0x56, 0xDE, 0x44, 0xAA, 0x04, 0xDE, 0xBC, 0x00, 0xDE, 0xDE, 0xDE, 0x00, 0x9A, 0x9A, 0x03, 0x44, 0x44, 0x44, 0x66, 0x44, 0xCC, 0x88, 0x33, 0xCD, 0xBC, 0xEF, 0x00, 0xBB, 0x55, 0x33, 0x22, 0x33, 0xCC, 0xDE, 0xEF, 0xAB, 0x02, 0x44, 0x22, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x01, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0xDE, 0xDE, 0xDE, 0x00, 0x00, 0x00, 0x03, 0xBA, 0xFE, 0xCA, 0x2B, 0xC5, 0x23, 0xDE, 0x00, 0xDE, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0x98, 0xDC, 0xA8, 0x01, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x66, 0x22, 0x00, 0x00, 0x00, 0x00, 0x9A, 0xDE, 0x00, 0x00, 0x00, 0x00, 0x02, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x22, 0x22, 0x44, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x66, 0x22, 0x66, 0xBC, 0xDE, 0xDE, 0xBC, 0xDE, 0xDE, 0x66, 0x22, 0x66, 0x00, 0x00, 0x00, 0x01, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0xDE, 0xDE, 0xDE, 0x00, 0x00, 0x00, 0x03, 0xBA, 0xFE, 0xCA, 0xE7, 0xC5, 0xDF, 0x66, 0x44, 0xCC, 0xDE, 0xEF, 0xAB, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x77, 0x55, 0xDD, 0x00, 0x11, 0xCD, 0x98, 0xDC, 0xA8, 0x04, 0xCE, 0x46, 0xBE, 0xDE, 0xDE, 0xDE, 0x22, 0x66, 0x00, 0x00, 0xBC, 0x00, 0xCC, 0x88, 0x66, 0x00, 0x00, 0x00, 0xDE, 0xBC, 0xBC, 0x22, 0x44, 0x44, 0xDE, 0xBC, 0xBC, 0x56, 0xBC, 0xDE, 0x22, 0x44, 0x00, 0xDE, 0x78, 0xDE, 0xCE, 0x68, 0x24, 0x04, 0x00, 0x22, 0x66, 0x66, 0x00, 0x00, 0xDE, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x9A, 0x9A, 0x9A, 0x9A, 0xDE, 0x00, 0xCC, 0x88, 0x66, 0x34, 0x78, 0x9A, 0x66, 0x22, 0x00, 0x00, 0x00, 0x00, 0xDE, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x9A, 0x02, 0x00, 0xDE, 0x9A, 0xBC, 0x00, 0xBC, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x9A, 0xDE, 0x00, 0xAA, 0x44, 0x22, 0x34, 0x78, 0x9A, 0xAA, 0x44, 0x22, 0x9A, 0xDE, 0x00, 0x22, 0x22, 0x22, 0x00, 0xDE, 0x9A, 0x00, 0x00, 0x00, 0xBC, 0x00, 0xBC, 0x01, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x88, 0x88, 0xCC, 0xDE, 0xBC, 0x00, 0x00, 0xDE, 0x9A, 0x9A, 0xDE, 0x9A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x44, 0x00, 0x44, 0x00, 0x22, 0x66, 0x9A, 0xBC, 0x34, 0x00, 0x00, 0x00, 0x01, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
//    deinterlace(interlaced_data, 13, 12);

// DYNAMIC HUFFMAN

   // uint8_t dynamic_huffman[] = { 0xAD, 0x97, 0x7F, 0x4C, 0x94, 0xF7, 0x1D, 0xC7, 0x5F, 0xCF, 0x73, 0x77, 0xC8, 0xC1, 0x71, 0xE4, 0x8E, 0x1F, 0x27, 0x87, 0xA8, 0x27, 0xA2, 0x16, 0x66, 0xB4, 0x2B, 0x05, 0x31, 0x42, 0x65, 0xE2, 0x8F, 0x9A, 0xFE, 0x70, 0x25, 0x4D, 0xDB, 0x65, 0x4E, 0x67, 0x5A, 0x66, 0xDC, 0x26, 0xD6, 0x66, 0xEB, 0x4C, 0xD7, 0xBA, 0x64, 0x6B, 0xBB, 0xC5, 0xA4, 0x5D, 0xBA, 0xAE, 0x66, 0x3D, 0xB0, 0x23, 0xAD, 0x31, 0xDA, 0xCC, 0x96, 0x6E, 0x6D, 0x85, 0xC5, 0xD1, 0x6E, 0x5A, 0x71, 0x55, 0x1B, 0xCD, 0x80, 0xD4, 0x46, 0x8B, 0x55, 0x10, 0x0F, 0x38, 0xF1, 0x8E, 0xC3, 0x83, 0x3B, 0xEE, 0xB3, 0x3F, 0x9E, 0x07, 0x4A, 0x19, 0x07, 0xC7, 0xB1, 0x77, 0xF2, 0xE4, 0xFB, 0xFD, 0x3E, 0x9F, 0xEF, 0xF3, 0x7D, 0xBF, 0xF2, 0x7C, 0x7F, 0x2B, 0xFC, 0x1F, 0xF4, 0xE4, 0x93, 0xC7, 0xEC, 0x09, 0x09, 0x72, 0x72, 0xDD, 0xBA, 0x22, 0xE7, 0x95, 0x2B, 0x3D, 0xBF, 0xDA, 0xB6, 0x6D, 0xF1, 0xCB, 0xB1, 0x7E, 0xAB, 0xCE, 0xD4, 0x7C, 0xC7, 0x8E, 0x77, 0xD6, 0x59, 0x2C, 0x6A, 0x47, 0x4A, 0xCA, 0xAC, 0x25, 0x4E, 0xA7, 0xDD, 0x5A, 0x52, 0xB2, 0xE8, 0xA5, 0xE3, 0xC7, 0x7B, 0x6F, 0xB9, 0xDD, 0xAD, 0xBB, 0x62, 0xF9, 0x5E, 0x99, 0x24, 0x66, 0x00, 0x16, 0x01, 0x49, 0x40, 0x37, 0xF0, 0xD5, 0xF8, 0x0A, 0xD5, 0xD5, 0x7F, 0xFB, 0x6D, 0x7A, 0x7A, 0xD2, 0xCF, 0x0D, 0x06, 0x45, 0x89, 0x44, 0x84, 0xCA, 0xCA, 0xF2, 0x6F, 0xC4, 0x3B, 0x3B, 0xBD, 0xBE, 0xCB, 0x97, 0xBB, 0x9E, 0x7D, 0xE2, 0x89, 0x82, 0x57, 0xA6, 0x03, 0xB0, 0x1E, 0xF8, 0x09, 0xB0, 0x02, 0xB8, 0x04, 0xF8, 0x81, 0xD9, 0x80, 0x03, 0xF8, 0x00, 0x78, 0x6D, 0xEB, 0xD6, 0x37, 0x2E, 0xA4, 0xA5, 0x39, 0x9A, 0xD2, 0xD2, 0xCC, 0x2B, 0x46, 0x3E, 0x9A, 0x08, 0x60, 0x44, 0x57, 0xAF, 0xF6, 0x78, 0xDB, 0xDB, 0x3D, 0x3F, 0xAB, 0xAA, 0x2A, 0x38, 0x30, 0x3E, 0x36, 0xB6, 0x0B, 0x6C, 0xC0, 0x11, 0x60, 0x2F, 0xF0, 0x3A, 0x90, 0xA5, 0x43, 0xAC, 0x05, 0x96, 0x02, 0x2E, 0xE0, 0x1F, 0x26, 0xD3, 0xAC, 0xC3, 0xE7, 0xCE, 0x1D, 0xF4, 0x59, 0xAD, 0xEA, 0x8A, 0xF1, 0x8D, 0x45, 0x53, 0x4E, 0x4E, 0xBA, 0xBD, 0xB4, 0x34, 0xBF, 0xB6, 0xB1, 0xB1, 0xBB, 0xD7, 0xED, 0x6E, 0xF9, 0xE1, 0x44, 0x00, 0xA9, 0xC0, 0xDF, 0x81, 0x16, 0xA0, 0x14, 0xF8, 0x2B, 0x10, 0x06, 0xCC, 0x80, 0x1D, 0x30, 0x02, 0x81, 0xEA, 0xEA, 0x77, 0x32, 0xF6, 0xEC, 0xA9, 0x9F, 0x6B, 0xB5, 0xDA, 0x4C, 0xB5, 0xB5, 0x4F, 0x11, 0x0C, 0x06, 0x62, 0x65, 0x18, 0x05, 0x59, 0xB5, 0x2A, 0xFF, 0x40, 0x63, 0x63, 0x77, 0x6F, 0x4D, 0xCD, 0x7F, 0xB6, 0xC0, 0xD7, 0x5D, 0xF0, 0x16, 0xF0, 0x25, 0xF0, 0xAC, 0x5E, 0x5E, 0xA7, 0xE7, 0xF3, 0x80, 0x5B, 0x80, 0x3D, 0x3B, 0xBB, 0x80, 0x07, 0x1E, 0xD8, 0x91, 0x9E, 0x93, 0x93, 0x0F, 0x40, 0x63, 0x63, 0x0D, 0xBD, 0xBD, 0x1D, 0x3C, 0xF6, 0xD8, 0x5E, 0x60, 0xF2, 0x2E, 0x98, 0x48, 0x22, 0xE0, 0xF3, 0x05, 0xBE, 0x34, 0x00, 0xC5, 0x40, 0x15, 0xF0, 0x3D, 0x20, 0x02, 0x3C, 0x05, 0xFC, 0x42, 0x4F, 0x7F, 0xBA, 0x7B, 0xF7, 0xD1, 0xC6, 0xB2, 0xB2, 0x2D, 0x8F, 0xDB, 0xED, 0xF6, 0xF4, 0xFA, 0xFA, 0xDF, 0xA3, 0xAA, 0x06, 0xE6, 0xCC, 0x59, 0x82, 0xCB, 0xB5, 0x9C, 0x53, 0xA7, 0x8E, 0x62, 0x36, 0xA7, 0x90, 0x99, 0x39, 0x0F, 0x11, 0xC8, 0xCF, 0x77, 0xC5, 0x0C, 0xA0, 0x28, 0x90, 0x98, 0x98, 0x60, 0x53, 0x81, 0xC7, 0x81, 0x57, 0x80, 0x10, 0x50, 0x04, 0x6C, 0x47, 0xEB, 0x86, 0x7F, 0x6E, 0xDE, 0xBC, 0x3F, 0xD3, 0x6A, 0xB5, 0x9C, 0x4F, 0x4D, 0x35, 0xA7, 0x15, 0x14, 0x94, 0xB2, 0x7D, 0xFB, 0x1F, 0xF9, 0xE4, 0x93, 0xBF, 0x70, 0xE9, 0xD2, 0x67, 0xA8, 0xAA, 0x4A, 0x45, 0xC5, 0x36, 0x4E, 0x9E, 0x7C, 0x5B, 0x6F, 0x50, 0x8D, 0xC4, 0xEC, 0x3E, 0x46, 0x2A, 0xB0, 0x0A, 0x68, 0xD0, 0xCB, 0x3F, 0x06, 0x7E, 0x0D, 0xDC, 0x04, 0xF2, 0x0E, 0x1D, 0xDA, 0xD9, 0xB4, 0x6F, 0xDF, 0xC3, 0x89, 0x6E, 0xF7, 0x2E, 0xFA, 0xFA, 0x3C, 0x24, 0x27, 0xA7, 0xB2, 0x69, 0xD3, 0x6E, 0x1A, 0x1B, 0xDD, 0x00, 0x2C, 0x58, 0xB0, 0x9C, 0xBE, 0x3E, 0x0F, 0x7E, 0xBF, 0x17, 0x83, 0x41, 0x89, 0x6B, 0x4D, 0x51, 0x81, 0x6C, 0xE0, 0xAA, 0x5E, 0x5E, 0x06, 0x9C, 0xD0, 0xF3, 0x2F, 0xA4, 0xA6, 0x3A, 0xEA, 0x9E, 0x79, 0xE6, 0x5D, 0xEE, 0xBC, 0x73, 0x3D, 0x47, 0x8E, 0x3C, 0x3F, 0x6A, 0xDA, 0xDF, 0xDF, 0x87, 0xDF, 0xDF, 0x8B, 0xA2, 0x28, 0xE4, 0xE4, 0xDC, 0x41, 0x67, 0xE7, 0xC5, 0x78, 0xBC, 0x47, 0x01, 0x84, 0xAF, 0x07, 0xE3, 0x10, 0x90, 0xA8, 0xE7, 0x7B, 0xFA, 0xFB, 0xBD, 0xDF, 0xF9, 0xFC, 0xF3, 0xD3, 0x14, 0x16, 0xDE, 0x4B, 0x5F, 0xDF, 0x0D, 0x82, 0xC1, 0x7E, 0x00, 0x32, 0x32, 0xE6, 0xE2, 0xF5, 0x5E, 0x07, 0xC0, 0x62, 0xB1, 0x13, 0x08, 0xDC, 0x9A, 0x11, 0xC0, 0x17, 0xC0, 0x1D, 0x7A, 0xB9, 0x09, 0xA8, 0xD4, 0xF3, 0x3B, 0xB3, 0xB2, 0x16, 0xBC, 0xB1, 0x70, 0xE1, 0x5D, 0x0C, 0x0F, 0x87, 0x09, 0x85, 0x06, 0x31, 0x1A, 0x67, 0x01, 0x10, 0x0E, 0x0F, 0x61, 0x30, 0x18, 0x01, 0x10, 0x19, 0x46, 0x51, 0x26, 0x5B, 0x50, 0xA7, 0x06, 0x68, 0x00, 0x1E, 0xD6, 0xCB, 0x2F, 0x01, 0xDB, 0x80, 0x47, 0x81, 0xD0, 0xEA, 0xD5, 0x3F, 0x38, 0xA7, 0xAA, 0x2A, 0x0D, 0x0D, 0x6E, 0x96, 0x2C, 0x29, 0xC1, 0x68, 0x34, 0x11, 0x0E, 0x0F, 0xE1, 0xF1, 0xB4, 0x93, 0x99, 0x39, 0x0F, 0x80, 0xEE, 0xEE, 0xAF, 0x48, 0x4B, 0xCB, 0x8E, 0x1B, 0xC0, 0x08, 0xEC, 0x07, 0x4E, 0x01, 0x6E, 0xA0, 0x03, 0xA8, 0x00, 0x6A, 0x81, 0xE7, 0x0E, 0x1E, 0x7C, 0xEE, 0x5A, 0x4A, 0x8A, 0x1D, 0xA7, 0x73, 0x21, 0x95, 0x95, 0x4F, 0x03, 0x70, 0xF6, 0xEC, 0x31, 0x72, 0x73, 0xBF, 0x4D, 0x42, 0x82, 0x99, 0xA1, 0xA1, 0x20, 0x37, 0x6E, 0xB4, 0x93, 0x95, 0xB5, 0x10, 0x11, 0x22, 0xC4, 0xB1, 0xB9, 0x19, 0x81, 0x6B, 0xC0, 0x6F, 0x80, 0xB7, 0x81, 0x8D, 0x68, 0xEB, 0xFF, 0x6A, 0x20, 0x3B, 0x14, 0x0A, 0xBA, 0xAA, 0xAB, 0xF7, 0xCF, 0x33, 0x99, 0xAC, 0x8B, 0x00, 0xBA, 0xBA, 0x2E, 0xF3, 0xD1, 0x47, 0x6F, 0x51, 0x55, 0xA5, 0xED, 0x2D, 0xE7, 0xCF, 0x1F, 0x27, 0x2F, 0xEF, 0x6E, 0x4C, 0xA6, 0x59, 0x80, 0xC4, 0x3D, 0x0B, 0x00, 0xFE, 0x84, 0xB6, 0xFC, 0x9E, 0x06, 0x36, 0xA0, 0x0D, 0xCA, 0x0E, 0xE0, 0x84, 0xCB, 0x35, 0xBF, 0x54, 0x55, 0x95, 0xA1, 0x33, 0x67, 0x3E, 0xA4, 0xAE, 0x6E, 0x0F, 0x95, 0x95, 0x4F, 0x63, 0xB3, 0xCD, 0x26, 0x18, 0xEC, 0xA7, 0xA9, 0xE9, 0x4D, 0xCA, 0xCA, 0x1E, 0x8D, 0xC7, 0x77, 0x54, 0xE3, 0x47, 0x4F, 0x09, 0xF0, 0x3C, 0x30, 0x0F, 0xF8, 0x37, 0xE0, 0x03, 0x6C, 0x89, 0x89, 0x49, 0x15, 0x79, 0x79, 0x45, 0xB6, 0x0D, 0x1B, 0xAA, 0xB0, 0xD9, 0xB2, 0x70, 0x38, 0xDA, 0xA8, 0xA9, 0xA9, 0xC3, 0x6C, 0x5E, 0x4C, 0x45, 0x85, 0xB6, 0xB7, 0x28, 0x8A, 0xC2, 0xA6, 0x4D, 0xF7, 0xCC, 0x18, 0x60, 0x44, 0x59, 0xC0, 0x72, 0xC0, 0xA2, 0x43, 0x9C, 0x79, 0xF5, 0xD5, 0xD3, 0xEF, 0xF9, 0x7C, 0x03, 0x2B, 0x97, 0x2D, 0xFB, 0x80, 0x8D, 0x1B, 0xF7, 0xD1, 0xD2, 0x92, 0x4A, 0x7D, 0xFD, 0x51, 0x14, 0x7D, 0xFD, 0x89, 0x07, 0x20, 0x1C, 0x1E, 0xBE, 0x69, 0x8C, 0x12, 0xBB, 0xAE, 0x3F, 0xA3, 0x4A, 0x4E, 0x1E, 0x58, 0x63, 0xB1, 0x74, 0x7A, 0xD7, 0xAE, 0xFD, 0x83, 0x19, 0xA0, 0xA0, 0xE0, 0x16, 0x17, 0x2E, 0x7C, 0x46, 0x7B, 0xFB, 0x5D, 0xD3, 0x32, 0x1D, 0xD1, 0xE0, 0x60, 0x28, 0xD0, 0xDB, 0x3B, 0x70, 0x77, 0x34, 0x80, 0xFF, 0xD1, 0xD6, 0xAD, 0xE5, 0x32, 0x34, 0x64, 0xED, 0x34, 0x99, 0x82, 0xB9, 0x0C, 0x03, 0x06, 0x28, 0x29, 0x39, 0x14, 0x17, 0xC0, 0xE0, 0xE0, 0x50, 0x5F, 0x38, 0xEC, 0xCB, 0x5F, 0xB3, 0x26, 0xE3, 0xFA, 0x74, 0x46, 0xEE, 0x8B, 0x09, 0x09, 0xBE, 0x5C, 0xFA, 0x81, 0x87, 0x80, 0x08, 0xCC, 0x9F, 0x7F, 0x16, 0xA7, 0xB3, 0x6D, 0x5A, 0xE6, 0xB7, 0x6F, 0x07, 0x3D, 0x03, 0x03, 0xC1, 0xDC, 0xC2, 0xC2, 0x8C, 0xEB, 0x10, 0xE3, 0xBC, 0x15, 0x61, 0x3D, 0xA0, 0x1D, 0x32, 0xB7, 0x03, 0xEF, 0x01, 0xEF, 0x6B, 0xB1, 0xE2, 0xE2, 0x23, 0x31, 0x9B, 0x07, 0x02, 0xC1, 0xAB, 0x1D, 0x1D, 0x37, 0x5D, 0x2B, 0x57, 0xA6, 0x7A, 0x47, 0xDE, 0x4D, 0x09, 0x20, 0x42, 0x06, 0xF0, 0x67, 0x40, 0xE1, 0x4D, 0xE0, 0xA0, 0x1E, 0xD0, 0xF6, 0x26, 0x16, 0x2F, 0xFE, 0x18, 0xBB, 0xFD, 0x5A, 0x0C, 0xE6, 0xB7, 0xDB, 0xFD, 0xFE, 0xAE, 0x45, 0xF7, 0xDF, 0xEF, 0x1C, 0x18, 0xFB, 0x7E, 0x52, 0x00, 0x11, 0x14, 0xE0, 0x00, 0x30, 0x9B, 0xCB, 0x68, 0x47, 0xD5, 0x11, 0x9D, 0x06, 0x4E, 0x80, 0xA2, 0x08, 0xC5, 0xC5, 0x87, 0x27, 0x35, 0xF7, 0xFB, 0x03, 0xAD, 0x7E, 0xBF, 0x39, 0xAF, 0xBC, 0xDC, 0x15, 0x1C, 0x1F, 0x9B, 0xEA, 0x0F, 0xEC, 0x02, 0xEE, 0x23, 0x0C, 0x7C, 0x1F, 0x6D, 0x42, 0x8E, 0xD5, 0xEF, 0xB4, 0x64, 0xE9, 0xD2, 0x06, 0x2C, 0x96, 0x9E, 0x28, 0xE6, 0x03, 0xCD, 0x45, 0x45, 0x96, 0x82, 0xF2, 0x72, 0x25, 0x3C, 0x51, 0xDC, 0x10, 0xCD, 0x59, 0x84, 0x6F, 0x01, 0x87, 0x01, 0x23, 0xBF, 0x04, 0x0E, 0x4D, 0x50, 0xE9, 0x0B, 0xE0, 0x41, 0x50, 0x9D, 0x11, 0x22, 0x11, 0x23, 0x89, 0x89, 0x95, 0xDF, 0x08, 0x6B, 0xE6, 0xC9, 0x25, 0xD1, 0x3C, 0xA2, 0x4A, 0x84, 0x24, 0x11, 0x5A, 0x45, 0x10, 0xF9, 0x18, 0x11, 0x03, 0x22, 0x44, 0x79, 0x36, 0x23, 0x22, 0x48, 0x30, 0x98, 0x24, 0x17, 0x2F, 0xDE, 0x94, 0xB6, 0x36, 0x91, 0xB6, 0x36, 0x91, 0xE6, 0x66, 0xFF, 0xBB, 0xD3, 0x36, 0x1E, 0x03, 0xF0, 0xBA, 0x08, 0x22, 0x5E, 0x44, 0xE6, 0x4E, 0x62, 0x0E, 0x22, 0x46, 0x44, 0xDA, 0x35, 0x08, 0x8F, 0xE7, 0x45, 0x69, 0x6D, 0x15, 0x69, 0x6E, 0xF6, 0xD5, 0xCD, 0xC4, 0xFC, 0xBB, 0x22, 0x5A, 0x83, 0xF2, 0xE0, 0x14, 0xE6, 0x23, 0xCF, 0x4E, 0xAD, 0x7E, 0x28, 0xE4, 0x90, 0x4F, 0x3F, 0xED, 0xA8, 0x9D, 0x89, 0xF9, 0x1C, 0x11, 0x7A, 0x44, 0x10, 0x79, 0x2D, 0x46, 0x73, 0x10, 0x49, 0x42, 0xC4, 0xA3, 0x43, 0x0B, 0x3F, 0x8A, 0xD7, 0x5C, 0x15, 0xE1, 0xB8, 0x08, 0x22, 0x2D, 0x7A, 0xA3, 0xB1, 0x02, 0x80, 0xC8, 0xDE, 0x51, 0x80, 0x4B, 0x22, 0xD1, 0x07, 0xF7, 0x78, 0x8D, 0xEE, 0x86, 0x22, 0xEC, 0x01, 0x5E, 0x00, 0xE0, 0x18, 0x70, 0x12, 0xE8, 0x04, 0x3C, 0xC0, 0x0D, 0xB4, 0xAD, 0xC9, 0x83, 0x76, 0x6C, 0x9D, 0x48, 0x69, 0xC0, 0x15, 0x20, 0x19, 0x80, 0x47, 0x14, 0x85, 0x98, 0x96, 0xC8, 0xB1, 0x00, 0x0D, 0x68, 0x57, 0xB2, 0xC9, 0xE5, 0x05, 0xBA, 0xD0, 0x2E, 0xEC, 0xE3, 0x01, 0xB7, 0xA0, 0x9D, 0xA5, 0xE0, 0xAC, 0xA2, 0x50, 0x38, 0x5D, 0x00, 0x07, 0xDA, 0xD5, 0xDC, 0x81, 0x76, 0x1E, 0xC8, 0xD4, 0x53, 0x87, 0x9E, 0xCF, 0x88, 0xA5, 0xC1, 0x31, 0x2A, 0x53, 0x14, 0xFE, 0x15, 0x33, 0xC0, 0x54, 0x12, 0xC1, 0xA4, 0x83, 0x8C, 0x00, 0x66, 0x8C, 0x03, 0x74, 0xEA, 0xE9, 0x6C, 0xB4, 0x3B, 0xE6, 0x3D, 0x8A, 0x42, 0xCB, 0x54, 0xED, 0xFE, 0x17 };
   // unsigned char test_dynamic_data[4644] = {0}; // (32*4+1)*36
   // decompress_dynamic(dynamic_huffman, sizeof(dynamic_huffman), 32, 36, test_dynamic_data);
   // png_filter(test_dynamic_data, 128, 36, 4);
   // print_img_bytes(test_dynamic_data, 128, 36);
   return 0;
}